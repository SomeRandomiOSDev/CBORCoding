{"seeAlsoSections":[{"title":"Related Documentation","identifiers":["https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This library provides two top-level coders, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBORDecoder"},{"type":"text","text":", for encoding and decoding (respectively) CBOR encoded objects to\/from "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/codable"},{"type":"text","text":" types. These coders are modeled closely to Foundation’s own "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/jsonencoder"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/jsondecoder"},{"type":"text","text":" types for the sake of familiarity and ease of use."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows to how one might change a value in an encoded CBOR object:"}]},{"type":"codeListing","syntax":"swift","code":["struct Vehicle: Codable {","    var numberOfWheels: Int","    var color: String","    var mpg: Int","}","","\/\/ JSON Equivalent: { \"numberOfWheels\": 4, \"color\": \"black\", \"mpg\": 17 }","let cborData = Data(fromHexString: \"0xA36E6E756D6265724F66576865656C730465636F6C6F7265626C61636B636D706711\")","let decoder = CBORDecoder()","","var vehicle = try decoder.decode(Vehicle.self, from: cborData)","vehicle.color = \"red\"","","let updatedCBORData = try encoder.encode(vehicle)","print(\"CBOR: \\(hexString(updatedCBORData))\")","","\/* Prints:"," CBOR: 0xA36E6E756D6265724F66576865656C730465636F6C6F7263726564636D706711","*\/"]}]}],"variants":[{"paths":["\/documentation\/cborcoding"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/CBORCoding\/documentation\/CBORCoding","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A simple library for encoding and decoding "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" types to and from CBOR encoded objects."}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"CBORCoding","title":"CBORCoding","symbolKind":"module","role":"collection","modules":[{"name":"CBORCoding"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Coders","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBORDecoder"]},{"title":"Custom Encoding","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol"]},{"title":"CBOR Types","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/NegativeUInt64","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/SimpleValue","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bignum","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/DecimalFraction","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bigfloat","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthArray","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthMap","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthData","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/CBOREncoded"]},{"title":"Namespaces","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR"]}],"references":{"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthArray":{"role":"symbol","title":"CBOR.IndefiniteLengthArray","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthArray"}],"abstract":[{"type":"text","text":"CBOR supports containers whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"codeVoice","code":"IndefiniteLengthArray"},{"type":"text","text":" provides support for encoding (homogeneous) arrays whose"},{"type":"text","text":" "},{"type":"text","text":"length is undefined. This may be useful for sending to decoders that expect"},{"type":"text","text":" "},{"type":"text","text":"array lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthArray","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthArray"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengtharray"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.4.3":{"title":"RFC 8949 Section 3.4.3","titleInlineContent":[{"type":"text","text":"RFC 8949 Section"},{"type":"text","text":" "},{"type":"text","text":"3.4.3"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3"},"doc://CBORCoding/documentation/CBORCoding/CBOR":{"role":"symbol","title":"CBOR","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOR"}],"abstract":[{"type":"text","text":"A top level type for encapsulating types specific to the CBOR specification"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOR"}],"url":"\/documentation\/cborcoding\/cbor"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthMap":{"role":"symbol","title":"CBOR.IndefiniteLengthMap","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthMap"}],"abstract":[{"type":"text","text":"CBOR supports containers whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"codeVoice","code":"IndefiniteLengthMap"},{"type":"text","text":" provides support for encoding (homogeneous) dictionaries"},{"type":"text","text":" "},{"type":"text","text":"whose length is undefined. This may be useful for sending to decoders that"},{"type":"text","text":" "},{"type":"text","text":"expect map lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthMap","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthMap"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthmap"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.4.4":{"title":"RFC 8949 Section 3.4.4","titleInlineContent":[{"type":"text","text":"RFC 8949"},{"type":"text","text":" "},{"type":"text","text":"Section 3.4.4"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},"doc://CBORCoding/documentation/CBORCoding/CBORDecoder":{"role":"symbol","title":"CBORDecoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBORDecoder"}],"abstract":[{"type":"text","text":"An object that decodes instances of a data type from CBOR objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBORDecoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBORDecoder"}],"url":"\/documentation\/cborcoding\/cbordecoder"},"doc://CBORCoding/documentation/CBORCoding/CBOR/CBOREncoded":{"role":"symbol","title":"CBOR.CBOREncoded","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoded"}],"abstract":[{"type":"text","text":"A type that asserts its data is already in CBOR encoded format. No additional"},{"type":"text","text":" "},{"type":"text","text":"encoding is done on the contained byte data."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/CBOREncoded","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoded"}],"url":"\/documentation\/cborcoding\/cbor\/cborencoded"},"doc://CBORCoding/documentation/CBORCoding":{"role":"collection","title":"CBORCoding","abstract":[{"type":"text","text":"A simple library for encoding and decoding "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" types to and from CBOR encoded objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString":{"role":"symbol","title":"CBOR.IndefiniteLengthString","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthString"}],"abstract":[{"type":"text","text":"CBOR supports byte strings whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"text","text":"This is achieved by encoding definite length “chunks” of byte strings wrapped in"},{"type":"text","text":" "},{"type":"text","text":"a byte string header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthString"},{"type":"text","text":" "},{"type":"text","text":"provides support for encoding byte strings in this way. This may be useful for"},{"type":"text","text":" "},{"type":"text","text":"sending to decoders that expect byte string lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthString"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoder":{"role":"symbol","title":"CBOREncoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoder"}],"abstract":[{"type":"text","text":"An object that encodes instances of a data type as CBOR objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoder"}],"url":"\/documentation\/cborcoding\/cborencoder"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoderProtocol":{"role":"symbol","title":"CBOREncoderProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoderProtocol"}],"abstract":[{"type":"text","text":"A protocol that the "},{"type":"codeVoice","code":"encoder"},{"type":"text","text":" parameter of "},{"type":"codeVoice","code":"encode(to:)"},{"type":"text","text":" will conform to when"},{"type":"text","text":" "},{"type":"text","text":"encoding values using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder"},{"type":"text","text":" class."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoderProtocol"}],"url":"\/documentation\/cborcoding\/cborencoderprotocol"},"https://developer.apple.com/documentation/swift/codable":{"title":"Codable","titleInlineContent":[{"type":"text","text":"Codable"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/codable","url":"https:\/\/developer.apple.com\/documentation\/swift\/codable"},"https://datatracker.ietf.org/doc/html/rfc8949":{"title":"CBOR Specification","titleInlineContent":[{"type":"text","text":"CBOR Specification"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949"},"doc://CBORCoding/documentation/CBORCoding/CBOR/NegativeUInt64":{"role":"symbol","title":"CBOR.NegativeUInt64","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NegativeUInt64"}],"abstract":[{"type":"text","text":"CBOR supports encoding negative values normally outside of the range "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"codeVoice","code":"NegativeUInt64"},{"type":"text","text":" fulfils the remaining values not representable by "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":". The"},{"type":"text","text":" "},{"type":"text","text":"encoded value is equal to "},{"type":"codeVoice","code":"-1 - rawValue"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/NegativeUInt64","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"NegativeUInt64"}],"url":"\/documentation\/cborcoding\/cbor\/negativeuint64"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Bignum":{"role":"symbol","title":"CBOR.Bignum","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Bignum"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Big numbers as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bignum","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Bignum"}],"url":"\/documentation\/cborcoding\/cbor\/bignum"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Undefined":{"role":"symbol","title":"CBOR.Undefined","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Undefined"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Undefined values as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Undefined"}],"url":"\/documentation\/cborcoding\/cbor\/undefined"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Bigfloat":{"role":"symbol","title":"CBOR.Bigfloat","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Bigfloat"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Big floats as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},{"type":"text","text":". The value"},{"type":"text","text":" "},{"type":"text","text":"of this type is computed as follows: "},{"type":"codeVoice","code":"mantissa * (2 ^ exponent)"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bigfloat","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Bigfloat"}],"url":"\/documentation\/cborcoding\/cbor\/bigfloat"},"https://datatracker.ietf.org/doc/html/rfc8949#section-5.7":{"title":"RFC 8949 Section 5.7","titleInlineContent":[{"type":"text","text":"RFC 8949"},{"type":"text","text":" "},{"type":"text","text":"Section 5.7"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthData":{"role":"symbol","title":"CBOR.IndefiniteLengthData","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthData"}],"abstract":[{"type":"text","text":"CBOR supports byte data whose length isn’t defined at the time of encoding. This"},{"type":"text","text":" "},{"type":"text","text":"is achieved by encoding definite length “chunks” of byte data wrapped in a byte"},{"type":"text","text":" "},{"type":"text","text":"data header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthData"},{"type":"text","text":" provides"},{"type":"text","text":" "},{"type":"text","text":"support for encoding byte data in this way. This may be useful for sending to"},{"type":"text","text":" "},{"type":"text","text":"decoders that expect byte data lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthData","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthData"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthdata"},"https://developer.apple.com/documentation/foundation/jsondecoder":{"title":"JSONDecoder","titleInlineContent":[{"type":"text","text":"JSONDecoder"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/jsondecoder","url":"https:\/\/developer.apple.com\/documentation\/foundation\/jsondecoder"},"doc://CBORCoding/documentation/CBORCoding/CBOR/SimpleValue":{"role":"symbol","title":"CBOR.SimpleValue","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SimpleValue"}],"abstract":[{"type":"text","text":"CBOR Major Type 7 specifies multiple codes for simple data types (bool, floating"},{"type":"text","text":" "},{"type":"text","text":"point numbers, etc.). Many of the codes under major type 7 aren’t yet assigned"},{"type":"text","text":" "},{"type":"text","text":"to any particular type\/value. "},{"type":"codeVoice","code":"SimpleValue"},{"type":"text","text":" fills this gap by returning the"},{"type":"text","text":" "},{"type":"text","text":"exact encoded value for those codes that are unassigned or unused."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/SimpleValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SimpleValue"}],"url":"\/documentation\/cborcoding\/cbor\/simplevalue"},"https://developer.apple.com/documentation/foundation/jsonencoder":{"title":"JSONEncoder","titleInlineContent":[{"type":"text","text":"JSONEncoder"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/jsonencoder","url":"https:\/\/developer.apple.com\/documentation\/foundation\/jsonencoder"},"doc://CBORCoding/documentation/CBORCoding/CBOR/DecimalFraction":{"role":"symbol","title":"CBOR.DecimalFraction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DecimalFraction"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Decimal Fractions as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},{"type":"text","text":". The"},{"type":"text","text":" "},{"type":"text","text":"value of this type is computed as follows: "},{"type":"codeVoice","code":"mantissa * (10 ^ exponent)"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/DecimalFraction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DecimalFraction"}],"url":"\/documentation\/cborcoding\/cbor\/decimalfraction"}}}