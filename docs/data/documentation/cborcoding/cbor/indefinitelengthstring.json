{"seeAlsoSections":[{"title":"Related Documentation","identifiers":["https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2.3"]},{"title":"CBOR Types","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/NegativeUInt64","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/SimpleValue","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bignum","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/DecimalFraction","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bigfloat","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthArray","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthMap","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthData","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/CBOREncoded"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthString"}],"title":"CBOR.IndefiniteLengthString","roleHeading":"Structure","role":"symbol","symbolKind":"struct","externalID":"s:10CBORCoding4CBORO22IndefiniteLengthStringV","modules":[{"name":"CBORCoding"}],"navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthString"}]},"abstract":[{"type":"text","text":"CBOR supports byte strings whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"text","text":"This is achieved by encoding definite length “chunks” of byte strings wrapped in"},{"type":"text","text":" "},{"type":"text","text":"a byte string header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthString"},{"type":"text","text":" "},{"type":"text","text":"provides support for encoding byte strings in this way. This may be useful for"},{"type":"text","text":" "},{"type":"text","text":"sending to decoders that expect byte string lengths to be undefined."}],"sections":[],"identifier":{"url":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString","interfaceLanguage":"swift"},"relationshipsSections":[{"identifiers":["doc:\/\/CBORCoding\/Se","doc:\/\/CBORCoding\/SE","doc:\/\/CBORCoding\/SQ"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"hierarchy":{"paths":[["doc:\/\/CBORCoding\/documentation\/CBORCoding"],["doc:\/\/CBORCoding\/documentation\/CBORCoding","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR"]]},"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/init(wrapping:)","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/init(wrapping:chunkSize:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/chunks","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/stringValue"]},{"title":"Instance Methods","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/stringValue(as:)"]},{"title":"Default Implementations","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/Decodable-Implementations","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/Encodable-Implementations","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/Equatable-Implementations"],"generated":true}],"variants":[{"paths":["\/documentation\/cborcoding\/cbor\/indefinitelengthstring"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"symbol","primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthString"}],"languages":["swift"],"platforms":["macOS"]}]}],"references":{"doc://CBORCoding/SE":{"type":"unresolvable","title":"Swift.Encodable","identifier":"doc:\/\/CBORCoding\/SE"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Bigfloat":{"role":"symbol","title":"CBOR.Bigfloat","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Bigfloat"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Big floats as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},{"type":"text","text":". The value"},{"type":"text","text":" "},{"type":"text","text":"of this type is computed as follows: "},{"type":"codeVoice","code":"mantissa * (2 ^ exponent)"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bigfloat","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Bigfloat"}],"url":"\/documentation\/cborcoding\/cbor\/bigfloat"},"doc://CBORCoding/documentation/CBORCoding/CBOR":{"role":"symbol","title":"CBOR","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOR"}],"abstract":[{"type":"text","text":"A top level type for encapsulating types specific to the CBOR specification"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOR"}],"url":"\/documentation\/cborcoding\/cbor"},"https://datatracker.ietf.org/doc/html/rfc8949":{"title":"CBOR Specification","titleInlineContent":[{"type":"text","text":"CBOR Specification"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.2.3":{"title":"CBOR Indefinite-Length Byte Strings and Text Strings","titleInlineContent":[{"type":"text","text":"CBOR Indefinite-Length Byte Strings and Text Strings"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2.3","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2.3"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/stringValue":{"role":"symbol","title":"stringValue","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"stringValue"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"?"}],"abstract":[{"type":"text","text":"The string composed by joining together all of the data chunks and interpreting"},{"type":"text","text":" "},{"type":"text","text":"it as a UTF8 encoded string."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/stringValue","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/stringvalue"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString":{"role":"symbol","title":"CBOR.IndefiniteLengthString","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthString"}],"abstract":[{"type":"text","text":"CBOR supports byte strings whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"text","text":"This is achieved by encoding definite length “chunks” of byte strings wrapped in"},{"type":"text","text":" "},{"type":"text","text":"a byte string header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthString"},{"type":"text","text":" "},{"type":"text","text":"provides support for encoding byte strings in this way. This may be useful for"},{"type":"text","text":" "},{"type":"text","text":"sending to decoders that expect byte string lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthString"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring"},"doc://CBORCoding/documentation/CBORCoding/CBOR/NegativeUInt64":{"role":"symbol","title":"CBOR.NegativeUInt64","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NegativeUInt64"}],"abstract":[{"type":"text","text":"CBOR supports encoding negative values normally outside of the range "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"codeVoice","code":"NegativeUInt64"},{"type":"text","text":" fulfils the remaining values not representable by "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":". The"},{"type":"text","text":" "},{"type":"text","text":"encoded value is equal to "},{"type":"codeVoice","code":"-1 - rawValue"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/NegativeUInt64","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"NegativeUInt64"}],"url":"\/documentation\/cborcoding\/cbor\/negativeuint64"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Undefined":{"role":"symbol","title":"CBOR.Undefined","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Undefined"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Undefined values as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Undefined"}],"url":"\/documentation\/cborcoding\/cbor\/undefined"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthMap":{"role":"symbol","title":"CBOR.IndefiniteLengthMap","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthMap"}],"abstract":[{"type":"text","text":"CBOR supports containers whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"codeVoice","code":"IndefiniteLengthMap"},{"type":"text","text":" provides support for encoding (homogeneous) dictionaries"},{"type":"text","text":" "},{"type":"text","text":"whose length is undefined. This may be useful for sending to decoders that"},{"type":"text","text":" "},{"type":"text","text":"expect map lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthMap","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthMap"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthmap"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/Encodable-Implementations":{"role":"collectionGroup","title":"Encodable Implementations","abstract":[],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/Encodable-Implementations","kind":"article","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/encodable-implementations"},"doc://CBORCoding/Se":{"type":"unresolvable","title":"Swift.Decodable","identifier":"doc:\/\/CBORCoding\/Se"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/stringValue(as:)":{"role":"symbol","title":"stringValue(as:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"stringValue"},{"kind":"text","text":"("},{"kind":"externalParam","text":"as"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Encoding","preciseIdentifier":"s:SS10FoundationE8EncodingV"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"?"}],"abstract":[{"type":"text","text":"Composes a string by joining together all of the data chunks and interpreting it"},{"type":"text","text":" "},{"type":"text","text":"as a string with the given encoding."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/stringValue(as:)","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/stringvalue(as:)"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/init(wrapping:chunkSize:)":{"role":"symbol","title":"init(wrapping:chunkSize:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"wrapping"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":", "},{"kind":"externalParam","text":"chunkSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Initializes a new indefinite length string by breaking up a single string object"},{"type":"text","text":" "},{"type":"text","text":"into smaller chunks. The string is split on byte boundaries based on a UTF-8"},{"type":"text","text":" "},{"type":"text","text":"representation of the string, not on character boundaries."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/init(wrapping:chunkSize:)","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/init(wrapping:chunksize:)"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.4.3":{"title":"RFC 8949 Section 3.4.3","titleInlineContent":[{"type":"text","text":"RFC 8949 Section"},{"type":"text","text":" "},{"type":"text","text":"3.4.3"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/Decodable-Implementations":{"role":"collectionGroup","title":"Decodable Implementations","abstract":[],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/Decodable-Implementations","kind":"article","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/decodable-implementations"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/chunks":{"role":"symbol","title":"chunks","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"chunks"},{"kind":"text","text":": ["},{"kind":"typeIdentifier","text":"Data","preciseIdentifier":"s:10Foundation4DataV"},{"kind":"text","text":"]"}],"abstract":[{"type":"text","text":"The data chunks that make up this indefinite length string. The chunks"},{"type":"text","text":" "},{"type":"text","text":"themselves will be encoded with a definite length whereas the enclosing type"},{"type":"text","text":" "},{"type":"text","text":"will be encoded with an indefinite length."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/chunks","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/chunks"},"https://datatracker.ietf.org/doc/html/rfc8949#section-5.7":{"title":"RFC 8949 Section 5.7","titleInlineContent":[{"type":"text","text":"RFC 8949"},{"type":"text","text":" "},{"type":"text","text":"Section 5.7"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},"doc://CBORCoding/documentation/CBORCoding/CBOR/CBOREncoded":{"role":"symbol","title":"CBOR.CBOREncoded","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoded"}],"abstract":[{"type":"text","text":"A type that asserts its data is already in CBOR encoded format. No additional"},{"type":"text","text":" "},{"type":"text","text":"encoding is done on the contained byte data."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/CBOREncoded","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoded"}],"url":"\/documentation\/cborcoding\/cbor\/cborencoded"},"doc://CBORCoding/SQ":{"type":"unresolvable","title":"Swift.Equatable","identifier":"doc:\/\/CBORCoding\/SQ"},"doc://CBORCoding/documentation/CBORCoding":{"role":"collection","title":"CBORCoding","abstract":[{"type":"text","text":"A simple library for encoding and decoding "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" types to and from CBOR encoded objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding"},"doc://CBORCoding/documentation/CBORCoding/CBOR/SimpleValue":{"role":"symbol","title":"CBOR.SimpleValue","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SimpleValue"}],"abstract":[{"type":"text","text":"CBOR Major Type 7 specifies multiple codes for simple data types (bool, floating"},{"type":"text","text":" "},{"type":"text","text":"point numbers, etc.). Many of the codes under major type 7 aren’t yet assigned"},{"type":"text","text":" "},{"type":"text","text":"to any particular type\/value. "},{"type":"codeVoice","code":"SimpleValue"},{"type":"text","text":" fills this gap by returning the"},{"type":"text","text":" "},{"type":"text","text":"exact encoded value for those codes that are unassigned or unused."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/SimpleValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SimpleValue"}],"url":"\/documentation\/cborcoding\/cbor\/simplevalue"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.4.4":{"title":"RFC 8949 Section 3.4.4","titleInlineContent":[{"type":"text","text":"RFC 8949"},{"type":"text","text":" "},{"type":"text","text":"Section 3.4.4"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},"doc://CBORCoding/documentation/CBORCoding/CBOR/DecimalFraction":{"role":"symbol","title":"CBOR.DecimalFraction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DecimalFraction"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Decimal Fractions as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},{"type":"text","text":". The"},{"type":"text","text":" "},{"type":"text","text":"value of this type is computed as follows: "},{"type":"codeVoice","code":"mantissa * (10 ^ exponent)"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/DecimalFraction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DecimalFraction"}],"url":"\/documentation\/cborcoding\/cbor\/decimalfraction"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthData":{"role":"symbol","title":"CBOR.IndefiniteLengthData","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthData"}],"abstract":[{"type":"text","text":"CBOR supports byte data whose length isn’t defined at the time of encoding. This"},{"type":"text","text":" "},{"type":"text","text":"is achieved by encoding definite length “chunks” of byte data wrapped in a byte"},{"type":"text","text":" "},{"type":"text","text":"data header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthData"},{"type":"text","text":" provides"},{"type":"text","text":" "},{"type":"text","text":"support for encoding byte data in this way. This may be useful for sending to"},{"type":"text","text":" "},{"type":"text","text":"decoders that expect byte data lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthData","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthData"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthdata"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/init(wrapping:)":{"role":"symbol","title":"init(wrapping:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"wrapping"},{"kind":"text","text":": ["},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":"])"}],"abstract":[{"type":"text","text":"Initializes a new indefinite length string wrapping a given array of string"},{"type":"text","text":" "},{"type":"text","text":"chunks."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/init(wrapping:)","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/init(wrapping:)"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthArray":{"role":"symbol","title":"CBOR.IndefiniteLengthArray","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthArray"}],"abstract":[{"type":"text","text":"CBOR supports containers whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"codeVoice","code":"IndefiniteLengthArray"},{"type":"text","text":" provides support for encoding (homogeneous) arrays whose"},{"type":"text","text":" "},{"type":"text","text":"length is undefined. This may be useful for sending to decoders that expect"},{"type":"text","text":" "},{"type":"text","text":"array lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthArray","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthArray"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengtharray"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString/Equatable-Implementations":{"role":"collectionGroup","title":"Equatable Implementations","abstract":[],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString\/Equatable-Implementations","kind":"article","type":"topic","url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring\/equatable-implementations"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Bignum":{"role":"symbol","title":"CBOR.Bignum","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Bignum"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Big numbers as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bignum","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Bignum"}],"url":"\/documentation\/cborcoding\/cbor\/bignum"}}}