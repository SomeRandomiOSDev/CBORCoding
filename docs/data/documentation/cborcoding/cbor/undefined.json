{"seeAlsoSections":[{"title":"Related Documentation","identifiers":["https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"]},{"title":"CBOR Types","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/NegativeUInt64","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/SimpleValue","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bignum","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/DecimalFraction","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bigfloat","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthArray","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthMap","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthData","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/CBOREncoded"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Undefined"}],"title":"CBOR.Undefined","roleHeading":"Structure","role":"symbol","symbolKind":"struct","externalID":"s:10CBORCoding4CBORO9UndefinedV","modules":[{"name":"CBORCoding"}],"navigatorTitle":[{"kind":"identifier","text":"Undefined"}]},"abstract":[{"type":"text","text":"Type value for encoding\/decoding Undefined values as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},{"type":"text","text":"."}],"sections":[],"identifier":{"url":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined","interfaceLanguage":"swift"},"relationshipsSections":[{"identifiers":["doc:\/\/CBORCoding\/Se","doc:\/\/CBORCoding\/SE"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"hierarchy":{"paths":[["doc:\/\/CBORCoding\/documentation\/CBORCoding"],["doc:\/\/CBORCoding\/documentation\/CBORCoding","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR"]]},"topicSections":[{"title":"Default Implementations","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined\/Decodable-Implementations","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined\/Encodable-Implementations"],"generated":true}],"variants":[{"paths":["\/documentation\/cborcoding\/cbor\/undefined"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"symbol","primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Undefined"}],"languages":["swift"],"platforms":["macOS"]}]}],"references":{"doc://CBORCoding/documentation/CBORCoding":{"role":"collection","title":"CBORCoding","abstract":[{"type":"text","text":"A simple library for encoding and decoding "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" types to and from CBOR encoded objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Undefined":{"role":"symbol","title":"CBOR.Undefined","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Undefined"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Undefined values as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Undefined"}],"url":"\/documentation\/cborcoding\/cbor\/undefined"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthArray":{"role":"symbol","title":"CBOR.IndefiniteLengthArray","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthArray"}],"abstract":[{"type":"text","text":"CBOR supports containers whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"codeVoice","code":"IndefiniteLengthArray"},{"type":"text","text":" provides support for encoding (homogeneous) arrays whose"},{"type":"text","text":" "},{"type":"text","text":"length is undefined. This may be useful for sending to decoders that expect"},{"type":"text","text":" "},{"type":"text","text":"array lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthArray","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthArray"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengtharray"},"doc://CBORCoding/documentation/CBORCoding/CBOR/DecimalFraction":{"role":"symbol","title":"CBOR.DecimalFraction","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DecimalFraction"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Decimal Fractions as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},{"type":"text","text":". The"},{"type":"text","text":" "},{"type":"text","text":"value of this type is computed as follows: "},{"type":"codeVoice","code":"mantissa * (10 ^ exponent)"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/DecimalFraction","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DecimalFraction"}],"url":"\/documentation\/cborcoding\/cbor\/decimalfraction"},"doc://CBORCoding/documentation/CBORCoding/CBOR/CBOREncoded":{"role":"symbol","title":"CBOR.CBOREncoded","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoded"}],"abstract":[{"type":"text","text":"A type that asserts its data is already in CBOR encoded format. No additional"},{"type":"text","text":" "},{"type":"text","text":"encoding is done on the contained byte data."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/CBOREncoded","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoded"}],"url":"\/documentation\/cborcoding\/cbor\/cborencoded"},"https://datatracker.ietf.org/doc/html/rfc8949":{"title":"CBOR Specification","titleInlineContent":[{"type":"text","text":"CBOR Specification"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949"},"doc://CBORCoding/documentation/CBORCoding/CBOR/NegativeUInt64":{"role":"symbol","title":"CBOR.NegativeUInt64","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NegativeUInt64"}],"abstract":[{"type":"text","text":"CBOR supports encoding negative values normally outside of the range "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"codeVoice","code":"NegativeUInt64"},{"type":"text","text":" fulfils the remaining values not representable by "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":". The"},{"type":"text","text":" "},{"type":"text","text":"encoded value is equal to "},{"type":"codeVoice","code":"-1 - rawValue"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/NegativeUInt64","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"NegativeUInt64"}],"url":"\/documentation\/cborcoding\/cbor\/negativeuint64"},"doc://CBORCoding/documentation/CBORCoding/CBOR":{"role":"symbol","title":"CBOR","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOR"}],"abstract":[{"type":"text","text":"A top level type for encapsulating types specific to the CBOR specification"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOR"}],"url":"\/documentation\/cborcoding\/cbor"},"doc://CBORCoding/Se":{"type":"unresolvable","title":"Swift.Decodable","identifier":"doc:\/\/CBORCoding\/Se"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.4.4":{"title":"RFC 8949 Section 3.4.4","titleInlineContent":[{"type":"text","text":"RFC 8949"},{"type":"text","text":" "},{"type":"text","text":"Section 3.4.4"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthString":{"role":"symbol","title":"CBOR.IndefiniteLengthString","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthString"}],"abstract":[{"type":"text","text":"CBOR supports byte strings whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"text","text":"This is achieved by encoding definite length “chunks” of byte strings wrapped in"},{"type":"text","text":" "},{"type":"text","text":"a byte string header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthString"},{"type":"text","text":" "},{"type":"text","text":"provides support for encoding byte strings in this way. This may be useful for"},{"type":"text","text":" "},{"type":"text","text":"sending to decoders that expect byte string lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthString","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthString"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthstring"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Bignum":{"role":"symbol","title":"CBOR.Bignum","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Bignum"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Big numbers as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bignum","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Bignum"}],"url":"\/documentation\/cborcoding\/cbor\/bignum"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Undefined/Encodable-Implementations":{"role":"collectionGroup","title":"Encodable Implementations","abstract":[],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined\/Encodable-Implementations","kind":"article","type":"topic","url":"\/documentation\/cborcoding\/cbor\/undefined\/encodable-implementations"},"doc://CBORCoding/documentation/CBORCoding/CBOR/SimpleValue":{"role":"symbol","title":"CBOR.SimpleValue","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SimpleValue"}],"abstract":[{"type":"text","text":"CBOR Major Type 7 specifies multiple codes for simple data types (bool, floating"},{"type":"text","text":" "},{"type":"text","text":"point numbers, etc.). Many of the codes under major type 7 aren’t yet assigned"},{"type":"text","text":" "},{"type":"text","text":"to any particular type\/value. "},{"type":"codeVoice","code":"SimpleValue"},{"type":"text","text":" fills this gap by returning the"},{"type":"text","text":" "},{"type":"text","text":"exact encoded value for those codes that are unassigned or unused."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/SimpleValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SimpleValue"}],"url":"\/documentation\/cborcoding\/cbor\/simplevalue"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Bigfloat":{"role":"symbol","title":"CBOR.Bigfloat","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Bigfloat"}],"abstract":[{"type":"text","text":"Type value for encoding\/decoding Big floats as outlined in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.4"},{"type":"text","text":". The value"},{"type":"text","text":" "},{"type":"text","text":"of this type is computed as follows: "},{"type":"codeVoice","code":"mantissa * (2 ^ exponent)"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Bigfloat","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Bigfloat"}],"url":"\/documentation\/cborcoding\/cbor\/bigfloat"},"doc://CBORCoding/SE":{"type":"unresolvable","title":"Swift.Encodable","identifier":"doc:\/\/CBORCoding\/SE"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.4.3":{"title":"RFC 8949 Section 3.4.3","titleInlineContent":[{"type":"text","text":"RFC 8949 Section"},{"type":"text","text":" "},{"type":"text","text":"3.4.3"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.4.3"},"https://datatracker.ietf.org/doc/html/rfc8949#section-5.7":{"title":"RFC 8949 Section 5.7","titleInlineContent":[{"type":"text","text":"RFC 8949"},{"type":"text","text":" "},{"type":"text","text":"Section 5.7"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-5.7"},"doc://CBORCoding/documentation/CBORCoding/CBOR/Undefined/Decodable-Implementations":{"role":"collectionGroup","title":"Decodable Implementations","abstract":[],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/Undefined\/Decodable-Implementations","kind":"article","type":"topic","url":"\/documentation\/cborcoding\/cbor\/undefined\/decodable-implementations"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthData":{"role":"symbol","title":"CBOR.IndefiniteLengthData","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthData"}],"abstract":[{"type":"text","text":"CBOR supports byte data whose length isn’t defined at the time of encoding. This"},{"type":"text","text":" "},{"type":"text","text":"is achieved by encoding definite length “chunks” of byte data wrapped in a byte"},{"type":"text","text":" "},{"type":"text","text":"data header specifying indefinite length. "},{"type":"codeVoice","code":"IndefiniteLengthData"},{"type":"text","text":" provides"},{"type":"text","text":" "},{"type":"text","text":"support for encoding byte data in this way. This may be useful for sending to"},{"type":"text","text":" "},{"type":"text","text":"decoders that expect byte data lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthData","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthData"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthdata"},"doc://CBORCoding/documentation/CBORCoding/CBOR/IndefiniteLengthMap":{"role":"symbol","title":"CBOR.IndefiniteLengthMap","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IndefiniteLengthMap"}],"abstract":[{"type":"text","text":"CBOR supports containers whose length isn’t defined at the time of encoding."},{"type":"text","text":" "},{"type":"codeVoice","code":"IndefiniteLengthMap"},{"type":"text","text":" provides support for encoding (homogeneous) dictionaries"},{"type":"text","text":" "},{"type":"text","text":"whose length is undefined. This may be useful for sending to decoders that"},{"type":"text","text":" "},{"type":"text","text":"expect map lengths to be undefined."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOR\/IndefiniteLengthMap","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IndefiniteLengthMap"}],"url":"\/documentation\/cborcoding\/cbor\/indefinitelengthmap"}}}