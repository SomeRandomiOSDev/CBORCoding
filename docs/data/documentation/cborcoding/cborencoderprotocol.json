{"seeAlsoSections":[{"title":"Related Documentation","identifiers":["https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2.3"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoderProtocol"}],"title":"CBOREncoderProtocol","roleHeading":"Protocol","role":"symbol","symbolKind":"protocol","externalID":"s:10CBORCoding19CBOREncoderProtocolP","modules":[{"name":"CBORCoding"}],"navigatorTitle":[{"kind":"identifier","text":"CBOREncoderProtocol"}]},"abstract":[{"type":"text","text":"A protocol that the "},{"type":"codeVoice","code":"encoder"},{"type":"text","text":" parameter of "},{"type":"codeVoice","code":"encode(to:)"},{"type":"text","text":" will conform to when"},{"type":"text","text":" "},{"type":"text","text":"encoding values using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder"},{"type":"text","text":" class."}],"sections":[],"identifier":{"url":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol","interfaceLanguage":"swift"},"relationshipsSections":[{"identifiers":["doc:\/\/CBORCoding\/s7EncoderP"],"kind":"relationships","title":"Inherits From","type":"inheritsFrom"}],"hierarchy":{"paths":[["doc:\/\/CBORCoding\/documentation\/CBORCoding"]]},"topicSections":[{"title":"Creating Containers of Specific Lengths","identifiers":["doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol\/indefiniteLengthContainerContext(includingSubcontainers:_:)-7195t","doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol\/definiteLengthContainerContext(includingSubcontainers:_:)-4guss"]}],"variants":[{"paths":["\/documentation\/cborcoding\/cborencoderprotocol"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"symbol","primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoderProtocol"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","text":"Encoder","preciseIdentifier":"s:s7EncoderP"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol is provided as a means to add keyed and unkeyed containers in a way specfic to the CBOR specification: indefinite length containers. The specification provides indefinite length contains as a way to begin encoding a container of a particular type when the total amount of items that will be encoded is initially unknown."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder"},{"type":"text","text":" for encoding types, this isn’t necessarily the case. Still, the receiver of CBOR encoded data may expect containers encoded in a specfic format so this protocol provides a way of creating indefinite length containers while encoding values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example showcases how this protocol might be used in practice to modifiy how containers’ lengths will be encoded using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct MyStruct<T>: Encodable where T: Encodable {","","    var containersToEncode: [[T]]","","    func encode(to encoder: Encoder) throws {","        \/\/ When encoding this type (or any type) with a CBOREncoder, the `encoder`","        \/\/ parameter to this method will conform to CBOREncoderProtocol.","","        \/\/ Only encode this type for CBOR encoders","        guard let encoder = encoder as? CBOREncoderProtocol else { return }","","        \/\/ All top-level containers, and nested containers due to the","        \/\/ `includingSubcontainers` flag being set to `true`, will be encoded with indefinite","        \/\/ length.","        try encoder.indefiniteLengthContainerContext(includingSubcontainers: true) {","            var encoderContainer = encoder.unkeyedContainer()","","            \/\/ Encode all of the evenly indexed nested containers with definite length","            for (i, container) in containersToEncode.enumerated() {","                if (i % 2) == 0 {","                    try encoder.definiteLengthContainerContext() { \/\/ `includingSubcontainers` is `false`","                        try encoderContainer.encode(container)","                    }","                } else {","                    try encoderContainer.encode(container)","                }","            }","        }","    }","}","","\/\/ When `containers` is encoded the arrays will be encoded with the following lengths:","let containers: [[Int]] = [ \/\/ Top-Level: indefinite length","    [1],                    \/\/ Index 0: definite length","    [2, 3],                 \/\/ Index 1: indefinite length","    [4, 5, 6],              \/\/ Index 2: definite length","    [7, 8, 9, 10],          \/\/ Index 3: indefinite length","    [11, 12, 13, 14, 15]    \/\/ Index 4: definite length","]","","let encoder = CBOREncoder()","let myStruct = MyStruct(containersToEncode: containers)","let encodedContainers = try encoder.encode(myStruct)"]}]}],"references":{"doc://CBORCoding/s7EncoderP":{"type":"unresolvable","title":"Swift.Encoder","identifier":"doc:\/\/CBORCoding\/s7EncoderP"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoderProtocol":{"role":"symbol","title":"CBOREncoderProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoderProtocol"}],"abstract":[{"type":"text","text":"A protocol that the "},{"type":"codeVoice","code":"encoder"},{"type":"text","text":" parameter of "},{"type":"codeVoice","code":"encode(to:)"},{"type":"text","text":" will conform to when"},{"type":"text","text":" "},{"type":"text","text":"encoding values using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder"},{"type":"text","text":" class."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoderProtocol"}],"url":"\/documentation\/cborcoding\/cborencoderprotocol"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.2":{"title":"RFS 8949 Section 3.2","titleInlineContent":[{"type":"text","text":"RFS 8949 Section 3.2"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoderProtocol/indefiniteLengthContainerContext(includingSubcontainers:_:)-46exh":{"role":"symbol","title":"indefiniteLengthContainerContext(includingSubcontainers:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"indefiniteLengthContainerContext"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"R"},{"kind":"text","text":">("},{"kind":"externalParam","text":"includingSubcontainers"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":", () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"}],"abstract":[],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol\/indefiniteLengthContainerContext(includingSubcontainers:_:)-46exh","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding\/cborencoderprotocol\/indefinitelengthcontainercontext(includingsubcontainers:_:)-46exh"},"doc://CBORCoding/documentation/CBORCoding":{"role":"collection","title":"CBORCoding","abstract":[{"type":"text","text":"A simple library for encoding and decoding "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" types to and from CBOR encoded objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding","kind":"symbol","type":"topic","url":"\/documentation\/cborcoding"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoder":{"role":"symbol","title":"CBOREncoder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"CBOREncoder"}],"abstract":[{"type":"text","text":"An object that encodes instances of a data type as CBOR objects."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoder","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CBOREncoder"}],"url":"\/documentation\/cborcoding\/cborencoder"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoderProtocol/indefiniteLengthContainerContext(includingSubcontainers:_:)-7195t":{"defaultImplementations":1,"role":"symbol","title":"indefiniteLengthContainerContext(includingSubcontainers:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"indefiniteLengthContainerContext"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"R"},{"kind":"text","text":">("},{"kind":"externalParam","text":"includingSubcontainers"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":", () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"}],"abstract":[{"type":"text","text":"Configures the receiver to encode all containers encoded within the given block"},{"type":"text","text":" "},{"type":"text","text":"as indefinite length containers as specified in "},{"type":"reference","isActive":true,"identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2"},{"type":"text","text":"."}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol\/indefiniteLengthContainerContext(includingSubcontainers:_:)-7195t","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/cborcoding\/cborencoderprotocol\/indefinitelengthcontainercontext(includingsubcontainers:_:)-7195t"},"https://datatracker.ietf.org/doc/html/rfc8949":{"title":"CBOR Specification","titleInlineContent":[{"type":"text","text":"CBOR Specification"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949"},"https://datatracker.ietf.org/doc/html/rfc8949#section-3.2.3":{"title":"CBOR Indefinite-Length Byte Strings and Text Strings","titleInlineContent":[{"type":"text","text":"CBOR Indefinite-Length Byte Strings and Text Strings"}],"type":"link","identifier":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2.3","url":"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8949#section-3.2.3"},"doc://CBORCoding/documentation/CBORCoding/CBOREncoderProtocol/definiteLengthContainerContext(includingSubcontainers:_:)-4guss":{"defaultImplementations":1,"role":"symbol","title":"definiteLengthContainerContext(includingSubcontainers:_:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"definiteLengthContainerContext"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"R"},{"kind":"text","text":">("},{"kind":"externalParam","text":"includingSubcontainers"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":", () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"}],"abstract":[{"type":"text","text":"Configures the receiver to encode all containers encoded within the given block"},{"type":"text","text":" "},{"type":"text","text":"as definite length containers. This is how all containers are encoded by"},{"type":"text","text":" "},{"type":"text","text":"default. This method can be useful to explicitly encode a nested container as a"},{"type":"text","text":" "},{"type":"text","text":"definite length container from within the context of a call to"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol\/indefiniteLengthContainerContext(includingSubcontainers:_:)-46exh"}],"identifier":"doc:\/\/CBORCoding\/documentation\/CBORCoding\/CBOREncoderProtocol\/definiteLengthContainerContext(includingSubcontainers:_:)-4guss","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/cborcoding\/cborencoderprotocol\/definitelengthcontainercontext(includingsubcontainers:_:)-4guss"}}}